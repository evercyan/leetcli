package solution

// 二叉搜索树
// 若它的左子树不空, 则左子树上所有结点的值均小于它的根结点的值
// 若它的右子树不空, 则右子树上所有结点的值均大于它的根结点的值
// 其左右子树也分别为二叉搜索树

// 动态规划
// 根节点为 k, 左子树为 1 到 k-1, 右子树为 k+1 到 n
// 左子树种类为 l, 右子树种类为 r, 则整棵树种类为 l*r
// 故, 只要累加每一个 k 值的种类即可
// 有 dp[i] = dp[i-1] + dp[i-2] + ... + dp[0]

func numTrees(n int) int {

	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1

	for i := 2; i <= n; i++ {
		// 根节点为 i 时, 累加 i-1, i-2, ..., 0
		for j := 0; j < i; j++ {
			dp[i] += dp[j] * dp[i-1-j]
		}
	}

	return dp[n]
}
